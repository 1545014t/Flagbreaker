#include "networks.h"#include "game_lib.h"void menu(UDPsocket mySocket, IPaddress yourAddr);void game(UDPsocket mySocket, IPaddress yourAddr);static Status status=DISCONNECTED;static JUDGE judge=SELECT;int main(int argc, char *argv[]){  UDPsocket mySocket;  int myPort = 0; /*ポート番号自動割当*/  IPaddress yourAddr, fromAddr;  char buffer[MAX_MSG];  /*使用方法表示*/  if (argc == 1 || argc > 2) {    printf("usage:%s server_name", argv[0]);    exit(EXIT_FAILURE);  }  // SDL初期化  if(SDL_Init(SDL_INIT_EVERYTHING)){    fprintf(stderr, "ERROR:init SDL\n");    exit(EXIT_FAILURE);  }  // SDL_net初期化  if (SDLNet_Init() != 0) {    fprintf(stderr, "ERROR:init SDL_net\n");    SDLNet_Quit();    exit(EXIT_FAILURE);  }  initscr();  curs_set(0);  noecho();  cbreak();  start_color();  mySocket = client_socket_and_bind(myPort, argv[1], DEFAULT_PORT, &yourAddr);  init_color(COLOR_BLUE, 443, 470, 1000);  init_pair(1, COLOR_BLUE, COLOR_BLACK);  init_pair(2, COLOR_RED, COLOR_BLACK);  while (status == DISCONNECTED) {    send_open_session(mySocket, &yourAddr);    RECEIVE_FIRST(mySocket, buffer, &fromAddr);    if (sockaddr_in_cmp(&yourAddr, &fromAddr) == 0 && message_interpreter(buffer).control == SESSION_ESTABLISHED){      status = CONNECTED;    }  }  clear();  attron(COLOR_PAIR(1));  mvaddstr(0, 0, "|> Run.");  refresh();    /* メニュー画面へ */  menu(mySocket, yourAddr);    SDLNet_UDP_Close(mySocket);  clear();  mvaddstr(0, 0, "|> End.");  refresh();    endwin();  SDLNet_Quit();  SDL_Quit();  return 0;}void menu(UDPsocket mySocket, IPaddress yourAddr){  IPaddress fromAddr;  char buffer[MAX_MSG];  SDL_Surface *bgimg_menu = NULL, *bgimg_wait = NULL;  SDL_Event event;  int mouseX, mouseY;  // 乱数の初期化  srand((unsigned int)time(0));  rand(); rand(); rand(); rand(); rand();  //キーボードからの入力読み取りレート設定，初期化後に行う．  SDL_EnableKeyRepeat(100, 100);//初回後以後，100ms押されていたら繰り返し100ms毎に引き続き検出    // ウィンドウのタイトルとアイコン(→キャプション)を設定  // SDL_WM_SetCaption("Flag Breaker!!! メニュー画面", NULL);  SDL_WM_SetCaption("Flag Breaker!!! MENU", NULL);    bgimg_menu = IMG_Load("./bg/background_menu_image.png");  bgimg_wait = IMG_Load("./bg/waiting.png");      // ウィンドウの初期化  SDL_SetVideoMode(bgimg_menu->w,bgimg_menu->h,BPP,SDL_SWSURFACE);  screen = SDL_GetVideoSurface();    if (bgimg_menu == NULL) {    fprintf(stderr, "ERROR:load image:%s\n", SDL_GetError());    SDL_Quit();    return;  }    SDL_BlitSurface(bgimg_menu, NULL, screen, NULL);  SDL_Flip(screen);    /* マウスカーソルを表示 */  SDL_ShowCursor(1);      while (status == CONNECTED) {        if (judge == PAUSING) {   // 相手の応答待ち中      SDL_BlitSurface(bgimg_wait, NULL, screen, NULL);      SDL_Flip(screen);      if (SDL_PollEvent(&event)) {	if (event.type == SDL_QUIT) {	  send_close_session(mySocket, &yourAddr);	  status = DISCONNECTED;	}      }    }        if (judge == SELECT || judge == WAITED) {      if (SDL_PollEvent(&event)) {	switch (event.type) {	case SDL_QUIT:	  send_close_session(mySocket, &yourAddr);	  status = DISCONNECTED;	  break;	case SDL_MOUSEBUTTONDOWN:	  SDL_GetMouseState(&mouseX, &mouseY);	  if (330 < mouseX && mouseX < 752 && 422 < mouseY && mouseY < 547 ) {   // ゲーム開始押下時	    send_game_start(mySocket, &yourAddr);	    if (judge == WAITED) {	      judge = RUN;	    } else if (judge == SELECT) {	      judge = PAUSING;	    }		  } else if (334 < mouseX && mouseX < 752 && 613 < mouseY && mouseY < 734 ) {   // ゲーム終了押下時	    send_close_session(mySocket, &yourAddr);	    status = DISCONNECTED;	  }	  break;	      	default:	  break;	}      }   // if (SDL_PollEvent)    }   // if (judge)	    /* 受信メッセージ読み出し */    switch (RECEIVE_NORMAL(mySocket, buffer, &fromAddr)) {    case 1:   // 受信      /* 送信アドレス，送信ポートが通信相手と同じかどうかチェック */      if (sockaddr_in_cmp(&fromAddr, &yourAddr) == 0) {	switch (message_interpreter(buffer).control) {	case CLOSE_SESSION:	  status = DISCONNECTED;	  break;	case GAME_START:	  if (judge == PAUSING) {	    judge = RUN;	  } else if (judge == SELECT) {	    judge = WAITED;	  }	  break;	default:	  break;	}      }      break;          case 0:   // 未受信      break;          case -1:   // エラー      fprintf(stderr, "ERROR: SDLNet_UDP_Recv");      status = DISCONNECTED;      break;    }    if (judge == RUN) {   // ゲーム実行      game(mySocket, yourAddr);      /* 再描画 */      SDL_BlitSurface(bgimg_menu, NULL, screen, NULL);      SDL_Flip(screen);    }  }   // while (status)  drop_surface(bgimg_menu);  drop_surface(bgimg_wait);    return;}void game(UDPsocket mySocket, IPaddress yourAddr){  IPaddress fromAddr;  char buffer[MAX_MSG];  // for SDL  SDL_Rect rect;  SDL_Rect scr_rect, rect_tmp;  SDL_Rect scr_rect2, rect2_tmp;  SDL_Rect status_rect;  SDL_Rect mine_rect;  int sqr_bx, sqr_by;  SDL_Event event;  /*=================================*/  int preyour_squarex, preyour_squarey;  double premy_hp, premy_mp;  int damage_obj;  double damage_hp;  int itemcode;  int tmp_dir;  int tmp_youry;  keylock_flag = 0;   // keylockフラグ初期化    /*=================================*/  // SDL_WM_SetCaption("Flag Breaker!!! ゲーム画面", NULL);  SDL_WM_SetCaption("Flag Breaker!!! in Game CLIENT", NULL);  SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, BPP, SDL_HWSURFACE);  init_map();   // マップ初期化  init_my_status_and_rect(&rect_tmp, &scr_rect);   // myステータス初期化  init_your_status_and_rect(&rect2_tmp, &scr_rect2);   // yourステータス初期化  init_load_images();   // 画像読み込み初期化  init_rectsize(&rect);   // 画像の矩形情報設定  init_statuswindow(&status_rect);   // ステータスウィンドウ情報の設定  /* 描画 */  SDL_BlitSurface(background_image, NULL, screen, NULL);  SDL_BlitSurface(mycharacter.image, &rect, screen, &scr_rect);  SDL_BlitSurface(yourcharacter.image, &rect, screen, &scr_rect2);  SDL_BlitSurface(statuswindow_image, NULL, screen, &status_rect);  init_drawHP();   // HP描画  init_drawMP();   // MP描画  SDL_Flip(screen);    rect_tmp = scr_rect;  rect2_tmp = scr_rect2;  preyour_squarex = yourcharacter.square_x;  preyour_squarey = yourcharacter.square_y;  premy_hp = mycharacter.HP;  premy_mp = mycharacter.MP;    while (judge == RUN) {    if (keylock_flag) {   // keylock有効時      if (SDL_PollEvent(&event)) {   // 空処理	if (event.type == SDL_QUIT) {	  send_game_end(mySocket, &yourAddr);	  status = DISCONNECTED;	  break;	}      }    } else {   // keylock解除時      if (SDL_PollEvent(&event)) {	switch (event.type) {	case SDL_QUIT:  // 途中終了	  send_game_end(mySocket, &yourAddr);	  judge = SELECT;	  status = DISCONNECTED;	  break;	  	case SDL_KEYDOWN:	  switch(event.key.keysym.sym){	  case SDLK_z:	    if (mycharacter.MP >= 1) {	      mycharacter.MP--;	      drawMP(I);	      switch (attack(mycharacter.direction)) {   // 情報送信	      case you:		SEND_ATTACK(you, yourcharacter.HP);		break;	      case r_left:		SEND_ATTACK(r_left, r_left_HP);		break;	      case r_right:		SEND_ATTACK(r_right, r_right_HP);		break;	      case r_center:		SEND_ATTACK(r_center, r_center_HP);		break;	      case r_king:		SEND_ATTACK(r_king, r_king_HP);		break;	      case none:		SEND_ATTACK(none, 0);		break;	      default:		break;	      }	      draw_character(&mycharacter, screen, 1);	      draw_damaged_character(&yourcharacter, screen);	    }	    break;	    	  case SDLK_UP:	    mycharacter.direction = dirNorth;	    if (map[mycharacter.square_x-1][mycharacter.square_y] != object) {	      rect_tmp.y -= SQUARE_SIZE;	      mycharacter.square_x--;	      switch (map[mycharacter.square_x][mycharacter.square_y]) {	      case normal:		SDL_RemoveTimer(ptimer_id);		SDL_RemoveTimer(htimer_id);		break;	      case doku:		square_poison(dirNorth);		break;	      case heal:		square_heal(dirNorth);	      default:		break;	      }	    }	    break;	      	  case SDLK_DOWN:	    mycharacter.direction = dirSouth;	    if (map[mycharacter.square_x+1][mycharacter.square_y] != object) {	      rect_tmp.y += SQUARE_SIZE;	      mycharacter.square_x++;	      switch (map[mycharacter.square_x][mycharacter.square_y]) {	      case normal:		SDL_RemoveTimer(ptimer_id);		SDL_RemoveTimer(htimer_id);		break;	      case doku:		square_poison(dirSouth);		break;	      case heal:		square_heal(dirSouth);		break;	      default:		break;	      }	    }	    break;	  case SDLK_RIGHT:	    mycharacter.direction = dirEast;	    if (map[mycharacter.square_x][mycharacter.square_y+1] != object) {	      rect_tmp.x += SQUARE_SIZE;	      mycharacter.square_y++;	      switch (map[mycharacter.square_x][mycharacter.square_y]) {	      case normal:		SDL_RemoveTimer(ptimer_id);		SDL_RemoveTimer(htimer_id);		break;	      case doku:		square_poison(dirEast);		break;	      case heal:		square_heal(dirEast);		break;	      default:		break;	      }	    }	    break;	  case SDLK_LEFT:	    mycharacter.direction = dirWest;	    if (map[mycharacter.square_x][mycharacter.square_y-1] != object) {	      rect_tmp.x -= SQUARE_SIZE;	      mycharacter.square_y--;	      switch (map[mycharacter.square_x][mycharacter.square_y]) {	      case normal:		SDL_RemoveTimer(ptimer_id);		SDL_RemoveTimer(htimer_id);		break;	      case doku:		square_poison(dirWest);		break;	      case heal:		square_heal(dirWest);		break;	      default:		break;	      }	    }	    break;	  default:	    break;	  }  // switch(event.key.keysym.sym)	    	  /* 移動可能範囲の判定 */	  if(mycharacter.square_x <= MAP_SIZE_HEIGHT && mycharacter.square_y <=MAP_SIZE_WIDTH ){	    /*更新*/	    Update(&scr_rect);	    scr_rect = rect_tmp;	    mycharacter.dst_rect = scr_rect;	    /* 描画 */	    draw_character(&mycharacter, screen, 0);	  }	  else {	    rect_tmp = scr_rect;	  }	  /* 送信座標は反転したものを */	  tmp_youry = MAP_SIZE_WIDTH - (mycharacter.square_y + 1);	  switch (mycharacter.direction) {	  case dirEast:	    tmp_dir = dirWest;	    break;	  case dirWest:	    tmp_dir = dirEast;	    break;	  case dirSouth:	  case dirNorth:	    tmp_dir = mycharacter.direction;	    break;	  }	  /* 自身の位置と向きを相手に送信 */	  send_coordinateion(mySocket, &yourAddr, mycharacter.square_x, tmp_youry, tmp_dir);	  break;	    	default:	  break;	}   // switch (event.type)      }   // if (SDL_PollEvent    }   // if (keylock_flag)    switch (map[mycharacter.square_x][mycharacter.square_y]) {    case mine_set:   // 爆弾スイッチ押した      while (1) {    	sqr_by = (rand()%16)+1;    	sqr_bx = (rand()%10)+1;    	if (map[sqr_bx][sqr_by] == normal) break;      }      //画像を表示する位置をセット      mine_rect.x = sqr_by * SQUARE_SIZE;      mine_rect.y = sqr_bx * SQUARE_SIZE;      // randbombの位置送信      send_randbomb_appear(mySocket, &yourAddr, sqr_bx, MAP_SIZE_WIDTH - (sqr_by+1));      //mapの構造体を変更      map[sqr_bx][sqr_by] = mine;      //画像の表示      Update(&mycharacter.dst_rect);      draw_character(&mycharacter, screen, 0);      SDL_BlitSurface(mark_image, NULL, screen, &mine_rect);      SDL_Flip(screen);      map[mycharacter.square_x][mycharacter.square_y] = normal;      break;          case mine:      send_randbomb_explode(mySocket, &yourAddr, mycharacter.square_x, mycharacter.square_y);      func_mine(&mycharacter);      Update(&mycharacter.dst_rect);      draw_character(&mycharacter, screen, 0);      drawHP(I);      map[sqr_bx][sqr_by] = normal;      break;          case yakusou:      send_get_item(mySocket, &yourAddr, yakusou);      func_yakusou(&mycharacter);      Update(&mycharacter.dst_rect);      draw_character(&mycharacter, screen, 0);      drawHP(I);      map[mycharacter.square_x][mycharacter.square_y] = normal;      break;          case attackup:      send_get_item(mySocket, &yourAddr, attackup);      func_attackup(&mycharacter);      Update(&mycharacter.dst_rect);      draw_character(&mycharacter, screen, 0);      map[mycharacter.square_x][mycharacter.square_y] = normal;      break;          case elixir:      send_get_item(mySocket, &yourAddr, elixir);      func_elixir(&mycharacter);      Update(&mycharacter.dst_rect);      draw_character(&mycharacter, screen, 0);      drawMP(I);      map[mycharacter.square_x][mycharacter.square_y] = normal;      break;          default:      break;    }    if (mycharacter.HP != premy_hp || mycharacter.MP != premy_mp) {   // ステータス変更時      send_status(mySocket, &yourAddr, mycharacter.HP, mycharacter.MP);      if (mycharacter.HP <= 0) {  // リスポーン(毒沼など)      	send_respawn(mySocket, &yourAddr);      	/*********************************************      	 *                                           *      	 *           画像表示 & ペナルティ           *      	 *                                           *      	 *********************************************/    	SDL_RemoveTimer(ptimer_id);    	SDL_RemoveTimer(htimer_id);    	respawn(I, &rect_tmp, &scr_rect);      }      premy_hp = mycharacter.HP;      premy_mp = mycharacter.MP;    }   // if for status    if (r_king_HP == 0) {   // ゲーム終了      send_gameover(mySocket, &yourAddr);      SDL_RemoveTimer(ptimer_id);      SDL_RemoveTimer(htimer_id);      gamewin();      judge = SELECT;    }   // if for gameover    /* 受信メッセージ読み出し */    switch (RECEIVE_NORMAL(mySocket, buffer, &fromAddr)) {    case 1:   // 受信      /* 送信アドレス，送信ポートが通信相手と同じかどうかチェック */      if (sockaddr_in_cmp(&fromAddr, &yourAddr) == 0) {	switch (message_interpreter(buffer).control) {	case GAME_END:	  judge = SELECT;	  status = DISCONNECTED;	  break;	case COORDINATION:	  sscanf(message_interpreter(buffer).parameter,"%d:%d:%d",&yourcharacter.square_x, &yourcharacter.square_y, &yourcharacter.direction);	  if ( yourcharacter.square_y == (preyour_squarey - 1) ) { // 左に移動時	    rect2_tmp.x -= SQUARE_SIZE;	    map[preyour_squarex][preyour_squarey] = normal;	    preyour_squarey = yourcharacter.square_y;	  } else if ( yourcharacter.square_y == (preyour_squarey + 1) ) { // 右に移動時	    rect2_tmp.x += SQUARE_SIZE;	    map[preyour_squarex][preyour_squarey] = normal;	    preyour_squarey = yourcharacter.square_y;	  }	  if ( yourcharacter.square_x == (preyour_squarex - 1) ) { // 上に移動時	    rect2_tmp.y -= SQUARE_SIZE;	    map[preyour_squarex][preyour_squarey] = normal;	    preyour_squarex = yourcharacter.square_x;	  } else if ( yourcharacter.square_x == (preyour_squarex + 1) ) { // 下に移動時	    rect2_tmp.y += SQUARE_SIZE;	    map[preyour_squarex][preyour_squarey] = normal;	    preyour_squarex = yourcharacter.square_x;	  }	  map[yourcharacter.square_x][yourcharacter.square_y] = object;	  /* 更新 */	  Update(&scr_rect2);	  scr_rect2 = rect2_tmp;	  yourcharacter.dst_rect = scr_rect2;	  /* 描画 */	  draw_character(&yourcharacter, screen, 0);	  break;	case STATUS:	  sscanf(message_interpreter(buffer).parameter,"%lf:%lf",&yourcharacter.HP, &yourcharacter.MP);	  drawHP(you);	  drawMP(you);	  break;	case ATTACK:	  sscanf(message_interpreter(buffer).parameter,"%lf:%d:%lf", &yourcharacter.MP, &damage_obj, &damage_hp);	  drawMP(you);	  damage(damage_obj, damage_hp);	  draw_character(&yourcharacter, screen, 1);	  draw_damaged_character(&mycharacter, screen);	  break;	case ITEM_APPEAR:	  sscanf(message_interpreter(buffer).parameter, "%d", &itemcode);	  switch (itemcode) {	  case yakusou:	    set_yakusou();	    break;	  case attackup:	    set_attackup();	    break;	  case mine_set:	    set_mine_set();	    break;	  case elixir:	    set_elixir();	    break;	  default:	    break;	  }	  break;	case GET_ITEM:	  sscanf(message_interpreter(buffer).parameter, "%d", &itemcode);	  switch (itemcode) {	  case yakusou:	    func_yakusou(&yourcharacter);	    Update(&yourcharacter.dst_rect);	    draw_character(&yourcharacter, screen, 0);	    drawHP(you);	    map[yourcharacter.square_x][yourcharacter.square_y] = normal;	    break;	  case attackup:	    func_attackup(&yourcharacter);	    Update(&yourcharacter.dst_rect);	    draw_character(&yourcharacter, screen, 0);	    map[yourcharacter.square_x][yourcharacter.square_y] = normal;	    break;	  case elixir:	    func_elixir(&yourcharacter);	    Update(&yourcharacter.dst_rect);	    draw_character(&yourcharacter, screen, 0);	    drawMP(you);	    map[yourcharacter.square_x][yourcharacter.square_y] = normal;	    break;	  default:	    break;	  }	  break;	case BOMB_APPEAR:	  sscanf(message_interpreter(buffer).parameter, "%d:%d", &sqr_bx, &sqr_by);	  map[sqr_bx][sqr_by] = mine;	  break;	case BOMB_EXPLODE:	  sscanf(message_interpreter(buffer).parameter, "%d:%d", &sqr_bx, &sqr_by);	  yourcharacter.HP -= 5; //ダメージ量要検討	  if (yourcharacter.HP <= 0) {	    yourcharacter.HP = 0;	  }	  Update(&yourcharacter.dst_rect);	  draw_character(&yourcharacter, screen, 0);	  drawHP(you);	  map[sqr_bx][sqr_by] = normal;	  break;	case RESPAWN:	  respawn(you, &rect2_tmp, &scr_rect2);	  break;	case GAMEOVER:	  SDL_RemoveTimer(ptimer_id);	  SDL_RemoveTimer(htimer_id);	  gamelose();	  judge = SELECT;	  break;	default:	  break;	}      }      break;    case 0:   // 未受信      break;    case -1:   // エラー      fprintf(stderr, "ERROR: SDLNet_UDP_Recv");      judge = SELECT;      status = DISCONNECTED;      break;    }    if (mycharacter.HP <= 0) {   // リスポーン (相手の攻撃など)      send_respawn(mySocket, &yourAddr);      /*********************************************       *                                           *       *           画像表示 & ペナルティ           *       *                                           *       *********************************************/      SDL_RemoveTimer(ptimer_id);      SDL_RemoveTimer(htimer_id);      respawn(I, &rect_tmp, &scr_rect);    }        SDL_Delay(1);  }   // while (judge)  drop_surface(mycharacter.image);  drop_surface(yourcharacter.image);  return;}